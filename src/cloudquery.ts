import { execaCommand } from 'execa';
import ciParallelVars from 'ci-parallel-vars';
import * as core from '@actions/core';

export const initProvider = async (provider: string, additionalFlags: string) => {
  await execaCommand(`./cloudquery init ${provider} ${additionalFlags}`, {
    stdout: 'inherit',
  });
};

export const fetch = async (additionalFlags: string) =>
  await execaCommand(`./cloudquery fetch ${additionalFlags}`, {
    stdout: 'inherit',
  });

export const updateCredentials = async (config: string, db: Record<string, string | number>) => {
  // TODO: Once cloudquery supports configuring the dsn, we can remove this workaround
  let withCredentials = config;
  Object.entries(db).forEach(([key, value]) => {
    withCredentials = withCredentials.replace(
      new RegExp(`${key}.*=.*`),
      Number.isInteger(value) ? `${key} = ${value}` : `${key} = "${value}"`,
    );
  });
  return withCredentials;
};

const RESOURCES_PATTERN = /\sresources = \[([\s\S]+?)\]/gm;

const getAllResources = (inputResources: string[], config: string) => {
  const fetchAll = inputResources.some((resource) => resource === '*');
  if (!fetchAll) {
    // Use whatever was provider by the user
    return inputResources;
  }

  // Parse the resource list generated by `cloudquery init <provider>`
  const resources = RESOURCES_PATTERN.exec(config);
  if (!resources) {
    core.warning(`Failed parsing resource list from config`);
    return inputResources;
  }

  const resourceList = resources[1]
    .split(',')
    .map((s) => s.trim().replace(/"/g, ''))
    .filter(Boolean);

  return resourceList;
};

const shardResources = (resources: string[]) => {
  if (!ciParallelVars) {
    return resources;
  }

  const { index, total } = ciParallelVars;
  if (total > resources.length) {
    // More machines that resources to fetch, so we fetch a single resource per machine
    // or none if it's a redundant machine
    if (index < resources.length) {
      return resources.slice(index, index + 1);
    }
    return [];
  }
  const resourcesPerMachine = Math.floor(resources.length / total);
  const start = index * resourcesPerMachine;
  const machineResources =
    index === total - 1 ? resources.slice(start) : resources.slice(start, start + resourcesPerMachine);

  return machineResources;
};

export const getFetchResources = async (config: string, inputResources: string[]) => {
  const resources = getAllResources(inputResources, config);
  const shard = shardResources(resources);

  const resourcesString = `resources = [ ${shard.map((resource) => `"${resource}"`).join(',')} ]`;

  return config.replace(RESOURCES_PATTERN, resourcesString);
};
